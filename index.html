<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Spider web generator</title>
	</head>
	<body>
		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}

			body {
				height: 100vh;
				display: grid;
				place-items: center;
				background: hsl(0, 0%, 96%);
			}

			svg {
				width: 75vmin;
				height: 75vmin;
				background: hsl(0, 0%, 100%);
			}
		</style>
		<script type="module">
			import { SVG } from "https://cdn.skypack.dev/@svgdotjs/svg.js";
			import {
				spline,
				random,
				pointsInPath,
			} from "https://cdn.skypack.dev/@georgedoescode/generative-utils@1.0.0";
			import { findPointInCircle, half, calculateCurve } from "./utils.js";

			const WIDTH = 300;
			const HEIGHT = 300;
			const CENTER = { x: half(WIDTH), y: half(HEIGHT) };
			const COLOR = "black"
			const THICKNESS = .3;

			// Random parameters
			const AXEL_QUANTITY = () => random(10, 50)
			const WEB_TENSION = () => random(.3,1)
			const ANCHOR_QUANTITY = random(2, 30)

			const draw = SVG()
				.addTo("body")
				.size(WIDTH, HEIGHT)
				.viewbox(0, 0, WIDTH, HEIGHT);

			// Draw axels radiating from the center
			const axels = [];
			const angleIncrement = 360 / AXEL_QUANTITY();
			for (let angle = 0; angle <= 360; angle += angleIncrement * random(.5, 1.5)) {
				const length = random(100, 150)
				const end = findPointInCircle(CENTER.x, CENTER.y, length, angle);

				const line = draw
					.line(CENTER.x, CENTER.y, end.x, end.y)
					.stroke({ color: COLOR, width: THICKNESS, linecap: "round" });

				// Draw supporting web strand 25% of times
				const isAnchoringWeb = random([true,false, false, false])
				if(isAnchoringWeb){
					const supportEnd = findPointInCircle(CENTER.x, CENTER.y, 500, angle);
					draw
					.line(CENTER.x, CENTER.y, supportEnd.x, supportEnd.y)
					.stroke({ color: COLOR, width: THICKNESS, linecap: "round" });
				}

				axels.push(line);
			}

			// Close web by repeating first axel as last
			axels.push(axels[0]);

			// Split each axel into N anchors to stick web to
			const anchors = [];
			axels.forEach((line) => {
				// Add endpoint so that web closes on the edges
				const end = {x: line.node.getAttribute("x2"), y: line.node.getAttribute("y2")}
				const points = pointsInPath(line.node, ANCHOR_QUANTITY).map(({ x, y }) => ({ x, y }))
				anchors.push([end, ...points]);
			});

			// Connect anchor points of each adjacent web strand
			anchors.forEach((points, axelIndex) => {
				points.forEach((start, pointIndex) => {
					if (!anchors[axelIndex + 1]) return;

					const end = anchors[axelIndex + 1][pointIndex];
					const tension = pointIndex * WEB_TENSION();
					const curve = calculateCurve(start, end, tension);

					draw.path(curve).stroke({color: COLOR, width: THICKNESS}).fill("none");
				});
			});
		</script>
	</body>
</html>
